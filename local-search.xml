<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>java代码记录</title>
    <link href="/2023/01/16/java-record/"/>
    <url>/2023/01/16/java-record/</url>
    
    <content type="html"><![CDATA[<h1 id="去除URL中的token参数"><a href="#去除URL中的token参数" class="headerlink" title="去除URL中的token参数"></a>去除URL中的token参数</h1><h2 id="request"><a href="#request" class="headerlink" title="request"></a>request</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> String <span class="hljs-title function_">generateURIWithoutToken</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>    List&lt;String&gt; queryParams = Arrays.asList(request.getQueryString().split(<span class="hljs-string">&quot;&amp;&quot;</span>));<br>    <span class="hljs-keyword">if</span> (!queryParams.isEmpty()) &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">queryStringWithoutToken</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;?&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String param : queryParams) &#123;<br>            <span class="hljs-keyword">if</span> (!StringUtils.contains(param, TOKEN_NAME)) &#123;<br>                queryStringWithoutToken.append(param);<br>                queryStringWithoutToken.append(<span class="hljs-string">&quot;&amp;&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">newUrl</span> <span class="hljs-operator">=</span> queryStringWithoutToken.toString();<br>        <span class="hljs-keyword">return</span> request.getRequestURI() + newUrl.substring(<span class="hljs-number">0</span>, newUrl.length() - <span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> request.getRequestURI();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="string正则表达式"><a href="#string正则表达式" class="headerlink" title="string正则表达式"></a>string正则表达式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">removeParam</span><span class="hljs-params">(String url, String... name)</span> &#123;<br><span class="hljs-keyword">for</span> (String s : name) &#123;<br><span class="hljs-comment">// 使用replaceAll替换</span><br>url = url.replaceAll(<span class="hljs-string">&quot;&amp;?&quot;</span> + s + <span class="hljs-string">&quot;=[^&amp;]*&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> url;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="当使用-PathVariable时，如果参数中存在-x2F-的处理方法"><a href="#当使用-PathVariable时，如果参数中存在-x2F-的处理方法" class="headerlink" title="当使用@PathVariable时，如果参数中存在&#x2F;的处理方法"></a>当使用@PathVariable时，如果参数中存在&#x2F;的处理方法</h1><blockquote><p>这种方法会导致&#x2F;test1&#x2F;token&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;token返回结果为token&#x2F;token</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/test1/&#123;token&#125;/**&quot;, method = RequestMethod.GET)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">test1</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String token, HttpServletRequest request, HttpServletResponse response)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> request.getAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE).toString();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">bestMatchingPattern</span> <span class="hljs-operator">=</span> request.getAttribute(HandlerMapping.BEST_MATCHING_PATTERN_ATTRIBUTE).toString();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">arguments</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AntPathMatcher</span>().extractPathWithinPattern(bestMatchingPattern, path);<br>    String result;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != arguments &amp;&amp; !arguments.isEmpty()) &#123;<br>        result = token + <span class="hljs-string">&#x27;/&#x27;</span> + arguments;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        result = token;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这种方法需要自己设置pattern为value中token前的字段</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/test2/&#123;token&#125;/**&quot;, method = RequestMethod.GET)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">test2</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String token, <span class="hljs-meta">@NotNull</span> HttpServletRequest request, HttpServletResponse response)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/test2/&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">pathq</span> <span class="hljs-operator">=</span> request.getAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE).toString();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">bestMatchingPattern</span> <span class="hljs-operator">=</span> request.getAttribute(HandlerMapping.BEST_MATCHING_PATTERN_ATTRIBUTE).toString();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> bestMatchingPattern.indexOf(pattern);<br>    <span class="hljs-keyword">return</span> pathq.substring(i + pattern.length());<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="options请求（跨域预检）CSDN"><a href="#options请求（跨域预检）CSDN" class="headerlink" title="options请求（跨域预检）CSDN"></a>options请求（跨域预检）<a href="https://blog.csdn.net/weixin_43822787/article/details/121036722">CSDN</a></h1><ul><li><p>概述</p><ul><li>options 请求就是预检请求，可用于检测服务器允许的 http 方法。当发起跨域请求时，由于安全原因，触发一定条件时浏览器会在正式请求之前自动先发起 OPTIONS 请求，即 CORS 预检请求，服务器若接受该跨域请求，浏览器才继续发起正式请求。</li></ul></li><li><p>什么是options请求</p><ul><li>HTTP 的 OPTIONS 方法 用于获取目的资源所支持的通信选项。客户端可以对特定的 URL 使用 OPTIONS 方法，也可以对整站（通过将 URL 设置为”*”）使用该方法。(简而言之，就是可以用 options 请求去嗅探某个请求在对应的服务器中都支持哪种请求方法)。</li></ul></li><li><p>原因</p><ul><li>这是因为在跨域的情况下，在浏览器发起”复杂请求”时主动发起的。跨域共享标准规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。</li></ul></li><li><p>简单请求与复杂请求</p><ul><li><p>某些请求不会触发CORS预检请求，这样的请求一般称为 <strong>“简单请求”</strong> ，而会触发预检的请求则是 <strong>“复杂请求”</strong> 。</p></li><li><p>简单请求</p><blockquote><ul><li>请求方式为GET、HEAD、POST时的请求；</li><li>认为设置规范集合之内的首部字段，如Accept&#x2F;Accept-Language&#x2F;Content-Language&#x2F;Content-Type&#x2F;DPR&#x2F;Downlink&#x2F;Save-Data&#x2F;Viewport-Width&#x2F;Width;</li><li>Content-Type 的值仅限于下列三者之一,即application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain；</li><li>请求中的任意 XMLHttpRequestUpload对象均没有注册任何事件监听器；</li><li>请求中没有使用 ReadableStream对象。</li></ul></blockquote></li><li><p>复杂请求</p><blockquote><ul><li>PUT&#x2F;DELETE&#x2F;CONNECT&#x2F;OPTIONS&#x2F;TRACE&#x2F;PATCH;</li><li>人为设置了以下集合之外首部字段，即简单请求外的字段;</li><li>Content-Type 的值不属于下列之一，即application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain。</li></ul></blockquote></li></ul></li><li><p>option关键字段</p><ul><li><p>request header的关键字段</p><table><thead><tr><th>关键字段</th><th>作用</th></tr></thead><tbody><tr><td>Access-Control-Request-Method</td><td>告诉服务器实际请求所使用的 HTTP 方法</td></tr><tr><td>Access-Control-Request-Headers</td><td>告诉服务器实际请求所携带的自定义首部字段</td></tr><tr><td>Origin</td><td>发起请求的域名 （协议、域名、端口号）</td></tr></tbody></table></li><li><p>response header的关键字段</p><table><thead><tr><th>关键字段</th><th>作用</th></tr></thead><tbody><tr><td>Access-Control-Allow-Methods</td><td>返回了服务端允许的请求，包含 GET&#x2F;HEAD&#x2F;PUT&#x2F;PATCH&#x2F;POST&#x2F;DELETE</td></tr><tr><td>Access-Control-Allow-Credentials</td><td>允许跨域携带 cookie（跨域请求要携带 cookie 必须设置为 true）</td></tr><tr><td>Access-Control-Allow-Origin</td><td>允许跨域请求的域名，这个可以在服务端配置一些信任的域名白名单</td></tr><tr><td>Access-Control-Allow-Headers</td><td>客户端请求所携带的自定义首部字段</td></tr><tr><td>Access-Control-Max-Age</td><td>指定预检请求的结果能够被缓存多久</td></tr></tbody></table></li></ul></li><li><p>options请求优化</p><ul><li>当发起跨域请求时，简单请求只发起一次请求；复杂请求则需要2次，先发起options请求，确认目标资源是否支持跨域，浏览器会根据服务端响应的header自动处理剩余的请求，如果响应支持跨域，则继续发出正常请求；不支持的话，会在控制台显示错误。<br>所以，当触发预检时，跨域请求便会发送2次请求，增加请求次数，同时，也延迟了请求真正发起的时间，会严重地影响性能。</li><li>优化options请求的两种方法：<ul><li>用其它的跨域方式做跨域请求，将复杂请求转为简单请求，比如JSONP等；</li><li>对options请求进行缓存<ul><li><code>Access-Control-Max-Age</code> 这个响应首部表示预检请求的返回结果（即 <code>Access-Control-Allow-Methods</code> 和 <code>Access-Control-Allow-Headers</code> 提供的信息） 可以被缓存的最长时间，单位是秒。如果值为 -1，则表示禁用缓存，每一次请求都需要提供预检请求，即用 OPTIONS 请求进行检测。</li><li>服务器端设置 Access-Control-Max-Age 字段，那么当第一次请求该 URL 时会发出 OPTIONS 请求，浏览器会根据返回的 Access-Control-Max-Age 字段缓存该请求的 OPTIONS 预检请求的响应结果（具体缓存时间还取决于浏览器的支持的默认最大值，取两者最小值，一般为 10 分钟）。在缓存有效期内，该资源的请求（URL 和 header 字段都相同的情况下）不会再触发预检。（chrome 打开控制台可以看到，当服务器响应 Access-Control-Max-Age 时只有第一次请求会有预检，后面不会了。注意要开启缓存，去掉 disable cache 勾选。）</li></ul></li></ul></li></ul></li></ul><h1 id="跨域-CSDN"><a href="#跨域-CSDN" class="headerlink" title="跨域 CSDN"></a>跨域 <a href="https://blog.csdn.net/qq_38128179/article/details/84956552">CSDN</a></h1><h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><table><thead><tr><th>当前页面URL</th><th>被请求页面URL</th><th>是否跨域</th><th>原因</th></tr></thead><tbody><tr><td><a href="http://www.test.com/">http://www.test.com/</a></td><td><a href="http://www.test.com/index.html">http://www.test.com/index.html</a></td><td>N</td><td>同源（协议、域名、端口号相同）</td></tr><tr><td><a href="http://www.test.com/">http://www.test.com/</a></td><td><a href="https://www.test.com/index.html">https://www.test.com/index.html</a></td><td>Y</td><td>协议不同（http&#x2F;https）</td></tr><tr><td><a href="http://www.test.com/">http://www.test.com/</a></td><td><a href="http://www.baidu.com/">http://www.baidu.com/</a></td><td>Y</td><td>主域名不同（test&#x2F;baidu）</td></tr><tr><td><a href="http://www.test.com/">http://www.test.com/</a></td><td><a href="http://blog.test.com/">http://blog.test.com/</a></td><td>Y</td><td>子域名不同（www&#x2F;blog）</td></tr><tr><td><a href="http://www.test.com:8080/">http://www.test.com:8080/</a></td><td><a href="http://www.test.com:7001/">http://www.test.com:7001/</a></td><td>Y</td><td>端口号不同（8080&#x2F;7001）</td></tr></tbody></table><h2 id="非同源限制"><a href="#非同源限制" class="headerlink" title="非同源限制"></a>非同源限制</h2><ol><li>无法读取非同源网页的Cookie、LocalStorage和IndexedDB</li><li>无法接触非同源网页的DOM</li><li>无法向非同源地址发送AJAX请求</li></ol><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="1-设置document-domain解决无法读取非同源网页的Cookie问题"><a href="#1-设置document-domain解决无法读取非同源网页的Cookie问题" class="headerlink" title="1. 设置document.domain解决无法读取非同源网页的Cookie问题"></a>1. 设置document.domain解决无法读取非同源网页的Cookie问题</h3><blockquote><p>仅限主域相同，子域不同的跨域场景。</p></blockquote><p>因为浏览器是通过document.domain检验两个页面是否同源，因此只要设置相同的domain就可共享Cookie</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">document.domain = &#x27;test.com&#x27;;<br></code></pre></td></tr></table></figure><h3 id="2-跨文档通信API：window-postMessage"><a href="#2-跨文档通信API：window-postMessage" class="headerlink" title="2. 跨文档通信API：window.postMessage()"></a>2. 跨文档通信API：window.postMessage()</h3><p>解决：</p><ul><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间消息传递</li><li>页面与嵌套的iframe消息传递</li><li>上三种场景的跨域数据传递</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//父窗口打开一个子窗口</span><br><span class="hljs-keyword">var</span> openWindow = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;http://test2.com&#x27;</span>,<span class="hljs-string">&#x27;title&#x27;</span>);<br><br><span class="hljs-comment">//父窗口向子窗口发消息（第一个参数代表发送的内容，第二个参数代表接受消息窗口的url</span><br>openWindow.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;Nice to meet you&#x27;</span>,<span class="hljs-string">&#x27;http://test2.com&#x27;</span>);<br></code></pre></td></tr></table></figure><p>调用message时间，监听对方发的消息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">source</span>);<span class="hljs-comment">// 发送消息的窗口</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">origin</span>);<span class="hljs-comment">// 消息发送的网址</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>);<span class="hljs-comment">// 发送的消息</span><br>&#125;,<span class="hljs-literal">false</span>)<br></code></pre></td></tr></table></figure><h3 id="3-JSONP"><a href="#3-JSONP" class="headerlink" title="3. JSONP"></a>3. JSONP</h3><p>优点：简单实用，兼容性好；缺点：仅支持get请求</p><p>核心：网页通过添加一个&lt;script&gt;元素，向服务器请求JSON数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来。</p><ol><li><p>原生实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script src=<span class="hljs-string">&quot;http://test.com/data.php?callback=dosomething&quot;</span>&gt;&lt;/script&gt;<br><span class="hljs-comment">// 向服务器test.com发出请求，该请求的查询字符串有一个callback参数，用来指定回调函数的名字</span><br> <br><span class="hljs-comment">// 处理服务器返回回调函数的数据</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">dosomething</span>(<span class="hljs-params">res</span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// 处理获得的数据</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">data</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><p>jQuery ajax</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$.<span class="hljs-title function_">ajax</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://www.test.com:8080/login&#x27;</span>,<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>    <span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;jsonp&#x27;</span>,  <span class="hljs-comment">// 请求方式为jsonp</span><br>    <span class="hljs-attr">jsonpCallback</span>: <span class="hljs-string">&quot;handleCallback&quot;</span>,    <span class="hljs-comment">// 自定义回调函数名</span><br>    <span class="hljs-attr">data</span>: &#123;&#125;<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>Vue.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$http</span>.<span class="hljs-title function_">jsonp</span>(<span class="hljs-string">&#x27;http://www.domain2.com:8080/login&#x27;</span>, &#123;<br>    <span class="hljs-attr">params</span>: &#123;&#125;,<br>    <span class="hljs-attr">jsonp</span>: <span class="hljs-string">&#x27;handleCallback&#x27;</span><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res); <br>&#125;)<br></code></pre></td></tr></table></figure></li></ol><h3 id="4-CORS"><a href="#4-CORS" class="headerlink" title="4.CORS"></a>4.CORS</h3><p>CORS是跨域资源分享（Cross-Origin Resource Sharing）。W3C标准，跨院AJAX请求的根本解决办法。</p><ol><li><p>普通跨域请求：只需服务器端设置Access-Control-Allow-Origin</p></li><li><p>带cookie跨域请求：前后端都需要进行设置</p><ol><li><p>前端：根据xhr.withCredentials字段判断是否带有cookie</p><ol><li><p>原生ajax</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>(); <span class="hljs-comment">// IE8/9需用window.XDomainRequest兼容</span><br> <br><span class="hljs-comment">// 前端设置是否带cookie</span><br>xhr.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span>;<br> <br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;post&#x27;</span>, <span class="hljs-string">&#x27;http://www.domain2.com:8080/login&#x27;</span>, <span class="hljs-literal">true</span>);<br>xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span>);<br>xhr.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;user=admin&#x27;</span>);<br> <br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> == <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-title function_">alert</span>(xhr.<span class="hljs-property">responseText</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>jQuery ajax</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$.<span class="hljs-title function_">ajax</span>(&#123;<br>   <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://www.test.com:8080/login&#x27;</span>,<br>   <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>   <span class="hljs-attr">data</span>: &#123;&#125;,<br>   <span class="hljs-attr">xhrFields</span>: &#123;<br>       <span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">true</span>    <span class="hljs-comment">// 前端设置是否带cookie</span><br>   &#125;,<br>   <span class="hljs-attr">crossDomain</span>: <span class="hljs-literal">true</span>,   <span class="hljs-comment">// 会让请求头中包含跨域的额外信息，但不会含cookie</span><br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>vue-resource</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-property">http</span>.<span class="hljs-property">options</span>.<span class="hljs-property">credentials</span> = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li><li><p>axios</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ol></li><li><p>服务器端：主要是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的配置，就可以允许Ajax进行跨域的访问</p><ol><li><p>Java后台</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 导入包：import javax.servlet.http.HttpServletResponse;</span><br><span class="hljs-comment"> * 接口参数中定义：HttpServletResponse response</span><br><span class="hljs-comment"> */</span><br> <br><span class="hljs-comment">// 允许跨域访问的域名：若有端口需写全（协议+域名+端口），若没有端口末尾不用加&#x27;/&#x27;</span><br>response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="hljs-string">&quot;http://www.domain1.com&quot;</span>); <br> <br><span class="hljs-comment">// 允许前端带认证cookie：启用此项后，上面的域名不能为&#x27;*&#x27;，必须指定具体的域名，否则浏览器会提示</span><br>response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>); <br> <br><span class="hljs-comment">// 提示OPTIONS预检时，后端需要设置的两个常用自定义头</span><br>response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="hljs-string">&quot;Content-Type,X-Requested-With&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>Nodejs后台</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">var</span> server = http.<span class="hljs-title function_">createServer</span>();<br><span class="hljs-keyword">var</span> qs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;querystring&#x27;</span>);<br> <br>server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>    <span class="hljs-keyword">var</span> postData = <span class="hljs-string">&#x27;&#x27;</span>;<br> <br>    <span class="hljs-comment">// 数据块接收中</span><br>    req.<span class="hljs-title function_">addListener</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">chunk</span>) &#123;<br>        postData += chunk;<br>    &#125;);<br> <br>    <span class="hljs-comment">// 数据接收完毕</span><br>    req.<span class="hljs-title function_">addListener</span>(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        postData = qs.<span class="hljs-title function_">parse</span>(postData);<br> <br>        <span class="hljs-comment">// 跨域后台设置</span><br>        res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123;<br>            <span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span>: <span class="hljs-string">&#x27;true&#x27;</span>,     <span class="hljs-comment">// 后端允许发送Cookie</span><br>            <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="hljs-string">&#x27;http://www.domain1.com&#x27;</span>,    <span class="hljs-comment">// 允许访问的域（协议+域名+端口）</span><br>            <span class="hljs-comment">/* </span><br><span class="hljs-comment">             * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，</span><br><span class="hljs-comment">             * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-string">&#x27;Set-Cookie&#x27;</span>: <span class="hljs-string">&#x27;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&#x27;</span>  <span class="hljs-comment">// HttpOnly的作用是让js无法读取cookie</span><br>        &#125;);<br> <br>        res.<span class="hljs-title function_">write</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(postData));<br>        res.<span class="hljs-title function_">end</span>();<br>    &#125;);<br>&#125;);<br> <br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-string">&#x27;8080&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Server is running at port 8080...&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>PHP后台</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br> <span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&quot;Access-Control-Allow-Origin:*&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>Apache需要mod_headers模块来激活HTTP头的设置，它默认是激活的。你只需要在Apache配置文件的&lt;Directory&gt;, &lt;Location&gt;, &lt;Files&gt;或&lt;VirtualHost&gt;的配置里加入以下内容即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">Header set Access-Control-Allow-Origin *<br></code></pre></td></tr></table></figure></li></ol></li></ol></li></ol><h3 id="5-webpack本地代理"><a href="#5-webpack本地代理" class="headerlink" title="5. webpack本地代理"></a>5. webpack本地代理</h3><p><img src="https://midnight-1312477196.cos.ap-nanjing.myqcloud.com/blog/image-20220818140236030.png" alt="image-20220818140236030.png"></p><p>在webpack.config.js中利用 WebpackDevServer 配置本地代理，详情配置查看<a href="https://webpack.docschina.org/configuration/dev-server/#root">devServer</a></p><h3 id="6-websocket"><a href="#6-websocket" class="headerlink" title="6. websocket"></a>6. websocket</h3><h3 id="7-Nginx反向代理"><a href="#7-Nginx反向代理" class="headerlink" title="7. Nginx反向代理"></a>7. Nginx反向代理</h3>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>record</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列</title>
    <link href="/2023/01/11/mq/"/>
    <url>/2023/01/11/mq/</url>
    
    <content type="html"><![CDATA[<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ"></a>什么是MQ</h3><p>MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常 见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不 用依赖其他服务。</p><h3 id="为什么要用MQ"><a href="#为什么要用MQ" class="headerlink" title="为什么要用MQ"></a>为什么要用MQ</h3><p>1.流量消峰 举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正 常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限 制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分 散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体 验要好。 </p><p>2.应用解耦 以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合 调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于 消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在 这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流 系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。 </p><p><img src="https://midnight-1312477196.cos.ap-nanjing.myqcloud.com/blog/20221221174644.png" alt="20221221174644.png"></p><p>3.异步处理 有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可 以执行完，以前一般有两种方式，A 过一段时间去调用 B 的查询 <code>api</code> 查询。或者 A 提供一个 <code>callback api</code>， B 执行完之后调用 <code>api</code> 通知 A 服务。这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题， A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消 息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 <code>api</code>，也不用提供 <code>callback api</code>。同样B 服务也不用 做这些操作。A 服务还能及时的得到异步处理成功的消息。</p><p><img src="https://midnight-1312477196.cos.ap-nanjing.myqcloud.com/blog/20221221174707.png" alt="20221221174707.png"></p><h3 id="MQ-的分类"><a href="#MQ-的分类" class="headerlink" title="MQ 的分类"></a>MQ 的分类</h3><h4 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a><code>ActiveMQ</code></h4><ul><li>优点：单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性较 低的概率丢失数据 </li><li>缺点:官方社区现在对 <code>ActiveMQ5</code>.x 维护越来越少，高吞吐量场景较少使用。</li><li><a href="http://www.gulixueyuan.com/course/322">学习视频</a></li></ul><h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a><code>Kafka</code></h4><blockquote><p>大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款为大数据而生的消息中间件， 以其百万级 TPS 的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥 着举足轻重的作用。目前已经被 LinkedIn，Uber, Twitter, Netflix 等大公司所采纳。 </p></blockquote><ul><li>优点: 性能卓越，单机写入 TPS 约在百万条&#x2F;秒，最大的优点，就是吞吐量高。时效性 ms 级可用性非 常高，<code>kafka</code>是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用,消费者采 用 Pull 方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;有优秀的第三方Kafka Web 管理界面 Kafka-Manager；在日志领域比较成熟，被多家公司和多个开源项目使用；功能支持： 功能 较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用 </li><li>缺点：Kafka 单机超过 64 个队列&#x2F;分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消 息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序， 但是一台代理宕机后，就会产生消息乱序，社区更新较慢；</li></ul><h4 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a><code>RocketMQ</code></h4><p><code>RocketMQ</code>出自阿里巴巴的开源产品，用 <code>Java</code> 语言实现，在设计时参考了 Kafka，并做出了自己的一 些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，<code>binglog</code> 分发等场 景。</p><ul><li>优点:单机吞吐量十万级,可用性非常高，分布式架构,消息可以做到 0 丢失,MQ 功能较为完善，还是分 布式的，扩展性好,支持 10 亿级别的消息堆积，不会因为堆积导致性能下降,源码是 java 我们可以自己阅 读源码，定制自己公司的 MQ</li><li>缺点：支持的客户端语言不多，目前是 <code>Java</code> 及 c++，其中 c++不成熟；社区活跃度一般,没有在MQ 核心中去实现 JMS 等接口,有些系统要迁移需要修改大量代码</li></ul><h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a><code>RabbitMQ</code></h4><blockquote><p>2007 年发布，是一个在AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最 主流的消息中间件之一。 </p></blockquote><ul><li>优点:由于 <code>erlang</code> 语言的高并发特性，性能较好；吞吐量到万级，MQ 功能比较完备,健壮、稳定、易 用、跨平台、支持多种语言 如：<code>Python</code>、<code>Ruby</code>、<code>.NET</code>、<code>Java</code>、<code>JMS</code>、<code>C</code>、<code>PHP</code>、<code>ActionScript</code>、<code>XMPP</code>、<code>STOMP</code> 等，支持 <code>AJAX</code> 文档齐全；开源提供的管理界面非常棒，用起来很好用,社区活跃度高；更新频率相当高 <a href="https://www.rabbitmq.com/news.html">https://www.rabbitmq.com/news.html</a> </li><li>缺点：商业版需要收费,学习成本较高<br><a href="/2023/01/12/mq-rabbitmq-01/">mq-rabbitmq-01</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>MQ</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>git生成并添加ssh公钥</title>
    <link href="/2023/01/11/git-ssh/"/>
    <url>/2023/01/11/git-ssh/</url>
    
    <content type="html"><![CDATA[<h1 id="生成SSH公钥"><a href="#生成SSH公钥" class="headerlink" title="生成SSH公钥"></a>生成SSH公钥</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">xxxxx@xxxxx.com是生成的 sshkey 的名称，并不约束或要求具体命名为某个邮箱</span><br>ssh-keygen -t ed25519 -C &quot;xxxxx@xxxxx.com&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">之后按照提示进行填写，也可直接按三次回车</span><br></code></pre></td></tr></table></figure><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><blockquote><p>生成完成后一般保存在当前用户文件夹下<code>.ssh</code>文件夹中以<code>.pub</code>结尾的文件中。</p><ul><li>Windows：%username%&#x2F;.ssh&#x2F;</li><li>Linux：~&#x2F;.ssh&#x2F;</li><li>右键使用记事本或VSCode打开均可。</li></ul></blockquote><h1 id="添加公钥"><a href="#添加公钥" class="headerlink" title="添加公钥"></a>添加公钥</h1><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><ol><li>点击头像-Settings-SSH and GPG keys-New SSH key</li></ol><p><img src="https://midnight-1312477196.cos.ap-nanjing.myqcloud.com/img/20221223091357.png"></p><ol start="2"><li>输入内容</li></ol><blockquote><ul><li>title随便</li><li>key：.pub文件中的内容</li></ul></blockquote><p><img src="https://midnight-1312477196.cos.ap-nanjing.myqcloud.com/img/20221223091552.png"></p><ol start="3"><li>验证</li></ol><p>打开终端输入<code>ssh -T git@github.com</code>若返回<code>Hi XXX! You&#39;ve successfully authenticated, but Gitee.com does not provide shell access.</code>内容，则证明添加成功</p><h2 id="Gitee"><a href="#Gitee" class="headerlink" title="Gitee"></a>Gitee</h2><ol><li>点击头像-账号设置-SSH公钥</li></ol><p><img src="https://midnight-1312477196.cos.ap-nanjing.myqcloud.com/img/20221223092030.png"></p><ol start="2"><li>输入内容</li></ol><blockquote><p>与Github教程一样即可</p></blockquote><ol start="3"><li>验证</li></ol><p>打开终端输入<code>ssh -T git@gitee.com</code>若返回<code>Hi XXX! You&#39;ve successfully authenticated, but Gitee.com does not provide shell access.</code>内容，则证明添加成功</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo搭建及使用</title>
    <link href="/2023/01/10/hexo/"/>
    <url>/2023/01/10/hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="官方指南"><a href="#官方指南" class="headerlink" title="官方指南"></a>官方指南</h1><p><a href="https://hexo.io/zh-cn/docs/index.html">https://hexo.io/zh-cn/docs/index.html</a></p><h1 id="部署hexo"><a href="#部署hexo" class="headerlink" title="部署hexo"></a>部署hexo</h1><ul><li>安装<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install hexo-cli -g<br></code></pre></td></tr></table></figure></li><li>生成博客目录<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo init blog<br>cd blog<br>npm install<br>hexo server<br></code></pre></td></tr></table></figure></li><li>出现<code>INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</code>即部署成功，访问<code>http://localhost:4000/</code>即可预览</li></ul><h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1><ul><li><a href="https://hexo.io/themes/">主题仓库</a></li></ul><h2 id="安装-以fluid为例，其他同理"><a href="#安装-以fluid为例，其他同理" class="headerlink" title="安装(以fluid为例，其他同理)"></a>安装(以<a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid</a>为例，其他同理)</h2><ul><li>命令行进入博客目录，并输入以下命令<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure></li><li>修改<code>_config.yml</code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">theme: fluid  # 指定主题<br>language: zh-CN  # 指定语言，会影响主题显示的语言，按需修改<br></code></pre></td></tr></table></figure></li><li>创建「关于页」<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new page about<br></code></pre></td></tr></table></figure>创建成功后，编辑博客目录下 <code>/source/about/index.md</code>，添加 <code>layout</code> 属性。<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">about</span><br><span class="hljs-attr">layout:</span> <span class="hljs-string">about</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">这里写关于页的正文，支持</span> <span class="hljs-string">Markdown,</span> <span class="hljs-string">HTML</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="将hexo部署到github"><a href="#将hexo部署到github" class="headerlink" title="将hexo部署到github"></a>将hexo部署到github</h1><blockquote><p>Gitee同理</p></blockquote><ol><li>GitHub新建同名公开仓库</li></ol><ul><li>比如你GitHub的用户名为abc，则新建一个名为abc.github.io的公开仓库。</li></ul><ol start="2"><li>修改<code>_config.yml</code>文件，</li></ol><ul><li>type：默认git即可</li><li>repo：按照自己的仓库进行修改</li><li>branch：推送到哪个分支<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:abc/abc.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br></code></pre></td></tr></table></figure></li></ul><ol start="3"><li>执行命令<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo d<br></code></pre></td></tr></table></figure>出现<code>INFO  Deploy done: git</code>即成功</li><li>进入仓库-setting-pages<br><img src="https://midnight-1312477196.cos.ap-nanjing.myqcloud.com/blog/20230116150207.png" alt="image.png"></li></ol><h1 id="将hexo部署到COS"><a href="#将hexo部署到COS" class="headerlink" title="将hexo部署到COS"></a>将hexo部署到COS</h1><ul><li>参考链接<ul><li><a href="https://www.lixl.cn/2020/020936412.html">https://www.lixl.cn/2020/020936412.html</a></li></ul></li><li>最直观的优点：<ul><li>访问速度快</li></ul></li><li>最直观的缺点：<ul><li>需要money（非大陆地区无需备案，但是会很慢）</li></ul></li></ul><h2 id="参考-部署到香港COS"><a href="#参考-部署到香港COS" class="headerlink" title="参考-部署到香港COS"></a>参考-部署到香港COS</h2><blockquote><p>加上域名预计每年花费不过百</p></blockquote><ol><li>新建存储桶-选择香港</li><li>安装插件<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install hexo-deployer-cos-cdn --save<br></code></pre></td></tr></table></figure></li><li>配置<code>_config.yml</code>文件</li></ol><ul><li>简单配置<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">deploy:</span> <br><span class="hljs-string">type:</span> <span class="hljs-string">cos-cdn</span><br><span class="hljs-string">cloud:</span> <span class="hljs-string">tencent</span><br><span class="hljs-string">bucket:</span> <span class="hljs-string">blog-1234567890</span><br><span class="hljs-string">region:</span> <span class="hljs-string">ap-hongkong</span><br><span class="hljs-string">secretId:</span> <span class="hljs-string">AKIDIgxxxxxxxxxxxxxxxxxxxx0SepjX</span><br><span class="hljs-string">secretKey:</span> <span class="hljs-string">qXPCbxxxxxxxxxxxxxxxxxxxxsJZfdR</span>  <br></code></pre></td></tr></table></figure></li><li>完整配置-1<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br><span class="hljs-string">type:</span> <span class="hljs-string">cos-cdn</span><br><span class="hljs-string">cloud:</span> <span class="hljs-string">tencent</span><br><span class="hljs-string">bucket:</span> <span class="hljs-string">blog-1234567890</span><br><span class="hljs-string">region:</span> <span class="hljs-string">ap-shanghai</span><br><span class="hljs-string">secretId:</span> <span class="hljs-string">AKIDIgxxxxxxxxxxxxxxxxxxxx0SepjX</span><br><span class="hljs-string">secretKey:</span> <span class="hljs-string">qXPCbxxxxxxxxxxxxxxxxxxxxsJZfdR</span><br><span class="hljs-attr">imageConfig:</span><br><span class="hljs-string">cloud:</span> <span class="hljs-string">aliyun</span><br><span class="hljs-string">cdnUrl:</span> <span class="hljs-string">https://pic.lixl.cn</span><br><span class="hljs-string">bucket:</span> <span class="hljs-string">lxl80</span><br><span class="hljs-string">region:</span> <span class="hljs-string">oss-cn-beijing</span><br><span class="hljs-string">folder:</span> <span class="hljs-string">static</span><br><span class="hljs-string">cdnEnable:</span> <span class="hljs-literal">false</span><br><span class="hljs-string">deleteExtraFiles:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure></li><li>完整配置-2<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">deploy:</span> <br><span class="hljs-string">-</span> <span class="hljs-string">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-string">repo:</span> <span class="hljs-string">https://github.com/lxl80/blog.git</span><br>  <span class="hljs-string">branch:</span> <span class="hljs-string">gh-pages</span><br>  <span class="hljs-string">ignore_hidden:</span> <span class="hljs-literal">false</span><br><span class="hljs-string">-</span> <span class="hljs-string">type:</span> <span class="hljs-string">cos-cdn</span><br>  <span class="hljs-string">cloud:</span> <span class="hljs-string">tencent</span><br>  <span class="hljs-string">bucket:</span> <span class="hljs-string">blog-1234567890</span><br>  <span class="hljs-string">region:</span> <span class="hljs-string">ap-shanghai</span><br>  <span class="hljs-string">cdnEnable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-string">deleteExtraFiles:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-string">updatePosts:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-string">secretId:</span> <span class="hljs-string">AKIDIgxxxxxxxxxxxxxxxxxxxx0SepjX</span><br>  <span class="hljs-string">secretKey:</span> <span class="hljs-string">qXPCbxxxxxxxxxxxxxxxxxxxxsJZfdR</span><br>  <span class="hljs-attr">imageConfig:</span><br>  <span class="hljs-string">cloud:</span> <span class="hljs-string">aliyun</span><br>  <span class="hljs-string">cdnUrl:</span> <span class="hljs-string">https://cdn.jsdelivr.net/gh/lxl80/blog@gh-pages/static</span><br>  <span class="hljs-string">bucket:</span> <span class="hljs-string">lxl80</span><br>  <span class="hljs-string">region:</span> <span class="hljs-string">oss-cn-beijing</span><br>  <span class="hljs-string">folder:</span> <span class="hljs-string">static</span><br>  <span class="hljs-string">cdnEnable:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-string">deleteExtraFiles:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ul><ol start="4"><li>推送<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean<br>hexo g<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">推送</span><br>hexo d<br></code></pre></td></tr></table></figure></li><li>开启COS静态网站，之后通过访问节点即可访问<br><img src="https://midnight-1312477196.cos.ap-nanjing.myqcloud.com/blog/20230116172838.png" alt="image.png"></li></ol><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><ol><li>购买域名</li><li>自定义域名<br><img src="https://midnight-1312477196.cos.ap-nanjing.myqcloud.com/blog/20230116173103.png" alt="image.png"></li><li>进入域名解析，将上述CNAME添加到域名解析的CNAME中，之后等待解析完成即可（时间较长，几个小时左右）<br><img src="https://midnight-1312477196.cos.ap-nanjing.myqcloud.com/blog/20230117104359.png" alt="image.png"></li></ol><h2 id="使用Obsidian管理"><a href="#使用Obsidian管理" class="headerlink" title="使用Obsidian管理"></a>使用Obsidian管理</h2><h3 id="模板快速生成Front-matter"><a href="#模板快速生成Front-matter" class="headerlink" title="模板快速生成Front-matter"></a>模板快速生成<code>Front-matter</code></h3><ul><li>obs设置-核心插件-模板，修改模板文件夹位置和日期格式<br><img src="https://midnight-1312477196.cos.ap-nanjing.myqcloud.com/blog/20230117105732.png" alt="image.png"></li><li>在该文件夹下新建模板md<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> &#123;&#123;<span class="hljs-string">title</span>&#125;&#125;<br><span class="hljs-attr">date:</span> &#123;&#123;<span class="hljs-string">date</span>&#125;&#125;<br><span class="hljs-attr">updated:</span> &#123;&#123;<span class="hljs-string">date</span>&#125;&#125;<br><span class="hljs-attr">comments:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">hide:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">excerpt:</span> <br><span class="hljs-attr">mermaid:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">tags:</span> <br><span class="hljs-bullet">-</span> []<br><span class="hljs-attr">categories:</span> <br><span class="hljs-bullet">-</span> []<br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure></li><li>使用时点击左侧的插入模板即可。</li></ul><h3 id="Obsidian-PicGo"><a href="#Obsidian-PicGo" class="headerlink" title="Obsidian+PicGo"></a>Obsidian+PicGo</h3><ol><li>obs安装插件<code>Image auto upload Plugin</code></li><li>安装<a href="https://picgo.github.io/PicGo-Doc/">PicGo</a></li><li>配置PicGo，网上教程很全，比如：<a href="https://cloud.tencent.com/developer/article/2067043">https://cloud.tencent.com/developer/article/2067043</a></li><li>按照自己的想法修改<code>Image auto upload Plugin</code>插件</li></ol><h3 id="hexo插件支持Obsidian双链"><a href="#hexo插件支持Obsidian双链" class="headerlink" title="hexo插件支持Obsidian双链"></a>hexo插件支持Obsidian双链</h3><blockquote><p>可以在网上自己找一个，或者自己写一个，随便推荐一个</p></blockquote><ul><li><a href="https://github.com/pondered/hexo-obsidian-backlink">hexo-obsidian-backlink</a></li></ul><h3 id="hexo-Obsidian-Excalidraw"><a href="#hexo-Obsidian-Excalidraw" class="headerlink" title="hexo+Obsidian+Excalidraw"></a>hexo+Obsidian+Excalidraw</h3><ol><li>Obsidian安装<code>Excalidraw</code>插件</li><li>配置里修改保存路径，放在_posts文件夹下的excalidraw文件夹中<br><img src="https://midnight-1312477196.cos.ap-nanjing.myqcloud.com/blog/20230117111822.png" alt="image.png"></li><li>开启自动导出PNG<br><img src="https://midnight-1312477196.cos.ap-nanjing.myqcloud.com/blog/20230117111836.png" alt="image.png"></li><li>使用时直接通过双链即可</li></ol><ul><li>一定要带上后缀</li><li>同时禁止excalidraw文件夹中md文件编译为博客网站<br><img src="https://midnight-1312477196.cos.ap-nanjing.myqcloud.com/blog/20230117113213.png" alt="image.png"><img src="/2023/01/10/hexo/images/Excalidraw-Test.png" alt="Excalidraw-Test.png"></li></ul><h3 id="hexo排除路径-禁止某些文件夹下的md文件转为博客"><a href="#hexo排除路径-禁止某些文件夹下的md文件转为博客" class="headerlink" title="hexo排除路径(禁止某些文件夹下的md文件转为博客)"></a>hexo排除路径(禁止某些文件夹下的md文件转为博客)</h3><ul><li>修改<code>_config.yml</code>文件中的<code>skip_render</code><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 例如需要禁止_posts/excalidraw文件夹下的md文件转为博客，则修改为以下即可。</span><br><span class="hljs-attr">skip_render:</span> <span class="hljs-string">&quot;_posts/excalidraw/**/*&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h1><ul><li>每次推送或者启动前先重新加载一遍。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean<br>hexo g<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">推送</span><br>hexo d<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动</span><br>hexo s<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello-World</title>
    <link href="/2023/01/10/hello-world/"/>
    <url>/2023/01/10/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
